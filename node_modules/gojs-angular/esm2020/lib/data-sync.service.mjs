import { Injectable } from '@angular/core';
import * as go from 'gojs';
import produce from "immer";
import * as i0 from "@angular/core";
export class DataSyncService {
    /**
     * Sync a node data array with a set of changes
     * @param changes The set of changes to the GoJS model
     * @param nodeData The node data array to merge these changes with
     * @param model Required if you have defined your model.nodeKeyProperty to be something other than 'key'
     * @returns A node data array, merged with the changes
     */
    static syncNodeData(changes, nodeData, model) {
        if (!changes)
            return nodeData;
        if (!changes.modifiedNodeData && !changes.insertedNodeKeys && !changes.removedNodeKeys)
            return nodeData;
        // maintain a map of modified nodes for fast lookup during insertion
        const modifiedNodesMap = new go.Map();
        // generate a map of keys -> indices for faster operations
        const keyIdxMap = new Map();
        nodeData.forEach((nd, idx) => {
            const key = model ? model.getKeyForNodeData(nd) : nd['key'];
            keyIdxMap.set(key, idx);
        });
        // nodeData is immutable, modify it using the immer package's "produce" function (creates new array)
        var newNodeDataArray = produce(nodeData, (draft) => {
            // account for modified node data
            if (changes.modifiedNodeData) {
                changes.modifiedNodeData.forEach((nd) => {
                    // Get the value of the node key property checking wether is a function or a string
                    const key = model ? model.getKeyForNodeData(nd) : nd['key'];
                    modifiedNodesMap.set(key, nd);
                    const idx = keyIdxMap.get(key);
                    if (idx !== undefined && idx >= 0) {
                        draft[idx] = nd;
                    }
                });
            }
            // account for inserted node data
            if (changes.insertedNodeKeys) {
                changes.insertedNodeKeys.forEach((key) => {
                    const nd = modifiedNodesMap.get(key);
                    if (nd && !keyIdxMap.has(key)) {
                        draft.push(nd);
                    }
                });
            }
            // account for removed node data
            if (changes.removedNodeKeys) {
                const removals = changes.removedNodeKeys.map(key => keyIdxMap.get(key)).sort();
                for (let i = removals.length - 1; i >= 0; i--) {
                    draft.splice(removals[i], 1);
                }
            }
        });
        return newNodeDataArray;
    }
    /**
     * Sync a link data array with a set of changes
     * @param changes The set of changes to the GoJS model
     * @param linkData The link data array to merge these changes with
     * @param model Required if you have defined your model.linkKeyProperty to be something other than 'key'
     * @returns A link data array, merged with the changes
     */
    static syncLinkData(changes, linkData, model) {
        if (!changes)
            return linkData;
        if (!changes.modifiedLinkData && !changes.insertedLinkKeys && !changes.removedLinkKeys)
            return linkData;
        // maintain a map of modified nodes for fast lookup during insertion
        const modifiedLinksMap = new go.Map();
        // generate a map of keys -> indices for faster operations
        const keyIdxMap = new Map();
        linkData.forEach((ld, idx) => {
            const key = model ? model.getKeyForLinkData(ld) : ld['key'];
            keyIdxMap.set(key, idx);
        });
        // linkData is immutable, modify it using the immer package's "produce" function (creates new array)
        linkData = produce(linkData, draft => {
            // account for modified link data
            if (changes.modifiedLinkData) {
                changes.modifiedLinkData.forEach((ld) => {
                    // Get the value of the link key
                    const key = model ? model.getKeyForLinkData(ld) : ld['key'];
                    modifiedLinksMap.set(key, ld);
                    const idx = keyIdxMap.get(key);
                    if (idx !== undefined && idx >= 0) {
                        draft[idx] = ld;
                    }
                });
            }
            // account for inserted link data
            if (changes.insertedLinkKeys) {
                changes.insertedLinkKeys.forEach((key) => {
                    const nd = modifiedLinksMap.get(key);
                    if (nd && !keyIdxMap.has(key)) {
                        draft.push(nd);
                    }
                });
            }
            // account for removed link data
            if (changes.removedLinkKeys) {
                const removals = changes.removedLinkKeys.map(key => keyIdxMap.get(key)).sort();
                for (let i = removals.length - 1; i >= 0; i--) {
                    draft.splice(removals[i], 1);
                }
            }
        });
        return linkData;
    }
    /**
     * Sync modelData with a set of changes
     * @param changes The set of changes to the GoJS model
     * @param modelData The modelData to merge these changes with
     * @returns A modelData object, merged with the changes
     */
    static syncModelData(changes, modelData) {
        if (!changes)
            return modelData;
        if (!changes.modelData)
            return modelData;
        if (changes.modelData) {
            return changes.modelData;
        }
    }
}
/** @nocollapse */ DataSyncService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.1.2", ngImport: i0, type: DataSyncService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
/** @nocollapse */ DataSyncService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.1.2", ngImport: i0, type: DataSyncService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.1.2", ngImport: i0, type: DataSyncService, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS1zeW5jLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9nb2pzLWFuZ3VsYXIvc3JjL2xpYi9kYXRhLXN5bmMuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sS0FBSyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNCLE9BQU8sT0FBb0IsTUFBTSxPQUFPLENBQUM7O0FBR3pDLE1BQU0sT0FBTyxlQUFlO0lBRTFCOzs7Ozs7T0FNRztJQUNJLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBMkIsRUFBRSxRQUE4QixFQUFFLEtBQWdCO1FBQ3RHLElBQUksQ0FBQyxPQUFPO1lBQUUsT0FBTyxRQUFRLENBQUM7UUFDOUIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxnQkFBZ0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxlQUFlO1lBQUUsT0FBTyxRQUFRLENBQUM7UUFFeEcsb0VBQW9FO1FBQ3BFLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUF5QixDQUFDO1FBQzdELDBEQUEwRDtRQUMxRCxNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztRQUM1QyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFO1lBQzNCLE1BQU0sR0FBRyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDNUQsU0FBUyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDMUIsQ0FBQyxDQUFDLENBQUM7UUFFSCxvR0FBb0c7UUFDcEcsSUFBSSxnQkFBZ0IsR0FB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Q0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7Z0JBQy9FLEtBQUssSUFBSSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtvQkFDN0MsS0FBSyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQzlCO2FBQ0Y7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sUUFBUSxDQUFDO0lBQ2xCLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBMkIsRUFBRSxTQUF3QjtRQUMvRSxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sU0FBUyxDQUFDO1FBQy9CLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUztZQUFFLE9BQU8sU0FBUyxDQUFDO1FBQ3pDLElBQUksT0FBTyxDQUFDLFNBQVMsRUFBRTtZQUNyQixPQUFPLE9BQU8sQ0FBQyxTQUFTLENBQUM7U0FDMUI7SUFDSCxDQUFDOzsrSEFoSVUsZUFBZTttSUFBZixlQUFlOzJGQUFmLGVBQWU7a0JBRDNCLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCAqIGFzIGdvIGZyb20gJ2dvanMnO1xyXG5pbXBvcnQgcHJvZHVjZSwgeyBjdXJyZW50IH0gZnJvbSBcImltbWVyXCI7XHJcblxyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBEYXRhU3luY1NlcnZpY2Uge1xyXG5cclxuICAvKipcclxuICAgKiBTeW5jIGEgbm9kZSBkYXRhIGFycmF5IHdpdGggYSBzZXQgb2YgY2hhbmdlc1xyXG4gICAqIEBwYXJhbSBjaGFuZ2VzIFRoZSBzZXQgb2YgY2hhbmdlcyB0byB0aGUgR29KUyBtb2RlbFxyXG4gICAqIEBwYXJhbSBub2RlRGF0YSBUaGUgbm9kZSBkYXRhIGFycmF5IHRvIG1lcmdlIHRoZXNlIGNoYW5nZXMgd2l0aFxyXG4gICAqIEBwYXJhbSBtb2RlbCBSZXF1aXJlZCBpZiB5b3UgaGF2ZSBkZWZpbmVkIHlvdXIgbW9kZWwubm9kZUtleVByb3BlcnR5IHRvIGJlIHNvbWV0aGluZyBvdGhlciB0aGFuICdrZXknXHJcbiAgICogQHJldHVybnMgQSBub2RlIGRhdGEgYXJyYXksIG1lcmdlZCB3aXRoIHRoZSBjaGFuZ2VzXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXRpYyBzeW5jTm9kZURhdGEoY2hhbmdlczogZ28uSW5jcmVtZW50YWxEYXRhLCBub2RlRGF0YTogQXJyYXk8Z28uT2JqZWN0RGF0YT4sIG1vZGVsPzogZ28uTW9kZWwpIHtcclxuICAgIGlmICghY2hhbmdlcykgcmV0dXJuIG5vZGVEYXRhO1xyXG4gICAgaWYgKCFjaGFuZ2VzLm1vZGlmaWVkTm9kZURhdGEgJiYgIWNoYW5nZXMuaW5zZXJ0ZWROb2RlS2V5cyAmJiAhY2hhbmdlcy5yZW1vdmVkTm9kZUtleXMpIHJldHVybiBub2RlRGF0YTtcclxuXHJcbiAgICAvLyBtYWludGFpbiBhIG1hcCBvZiBtb2RpZmllZCBub2RlcyBmb3IgZmFzdCBsb29rdXAgZHVyaW5nIGluc2VydGlvblxyXG4gICAgY29uc3QgbW9kaWZpZWROb2Rlc01hcCA9IG5ldyBnby5NYXA8Z28uS2V5LCBnby5PYmplY3REYXRhPigpO1xyXG4gICAgLy8gZ2VuZXJhdGUgYSBtYXAgb2Yga2V5cyAtPiBpbmRpY2VzIGZvciBmYXN0ZXIgb3BlcmF0aW9uc1xyXG4gICAgY29uc3Qga2V5SWR4TWFwID0gbmV3IE1hcDxnby5LZXksIG51bWJlcj4oKTtcclxuICAgIG5vZGVEYXRhLmZvckVhY2goKG5kLCBpZHgpID0+IHtcclxuICAgICAgY29uc3Qga2V5ID0gbW9kZWwgPyBtb2RlbC5nZXRLZXlGb3JOb2RlRGF0YShuZCkgOiBuZFsna2V5J107XHJcbiAgICAgIGtleUlkeE1hcC5zZXQoa2V5LCBpZHgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gbm9kZURhdGEgaXMgaW1tdXRhYmxlLCBtb2RpZnkgaXQgdXNpbmcgdGhlIGltbWVyIHBhY2thZ2UncyBcInByb2R1Y2VcIiBmdW5jdGlvbiAoY3JlYXRlcyBuZXcgYXJyYXkpXHJcbiAgICB2YXIgbmV3Tm9kZURhdGFBcnJheSA9IHByb2R1Y2Uobm9kZURhdGEsIChkcmFmdCkgPT4ge1xyXG4gICAgICAvLyBhY2NvdW50IGZvciBtb2RpZmllZCBub2RlIGRhdGFcclxuICAgICAgaWYgKGNoYW5nZXMubW9kaWZpZWROb2RlRGF0YSkge1xyXG4gICAgICAgIGNoYW5nZXMubW9kaWZpZWROb2RlRGF0YS5mb3JFYWNoKChuZDogZ28uT2JqZWN0RGF0YSkgPT4ge1xyXG4gICAgICAgICAgLy8gR2V0IHRoZSB2YWx1ZSBvZiB0aGUgbm9kZSBrZXkgcHJvcGVydHkgY2hlY2tpbmcgd2V0aGVyIGlzIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcclxuICAgICAgICAgIGNvbnN0IGtleSA9IG1vZGVsID8gbW9kZWwuZ2V0S2V5Rm9yTm9kZURhdGEobmQpIDogbmRbJ2tleSddO1xyXG4gICAgICAgICAgbW9kaWZpZWROb2Rlc01hcC5zZXQoa2V5LCBuZCk7XHJcbiAgICAgICAgICBjb25zdCBpZHggPSBrZXlJZHhNYXAuZ2V0KGtleSk7XHJcbiAgICAgICAgICBpZiAoaWR4ICE9PSB1bmRlZmluZWQgJiYgaWR4ID49IDApIHtcclxuICAgICAgICAgICAgZHJhZnRbaWR4XSA9IG5kO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhY2NvdW50IGZvciBpbnNlcnRlZCBub2RlIGRhdGFcclxuICAgICAgaWYgKGNoYW5nZXMuaW5zZXJ0ZWROb2RlS2V5cykge1xyXG4gICAgICAgIGNoYW5nZXMuaW5zZXJ0ZWROb2RlS2V5cy5mb3JFYWNoKChrZXk6IGdvLktleSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgbmQgPSBtb2RpZmllZE5vZGVzTWFwLmdldChrZXkpO1xyXG4gICAgICAgICAgaWYgKG5kICYmICFrZXlJZHhNYXAuaGFzKGtleSkpIHtcclxuICAgICAgICAgICAgZHJhZnQucHVzaChuZCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFjY291bnQgZm9yIHJlbW92ZWQgbm9kZSBkYXRhXHJcbiAgICAgIGlmIChjaGFuZ2VzLnJlbW92ZWROb2RlS2V5cykge1xyXG4gICAgICAgIGNvbnN0IHJlbW92YWxzID0gY2hhbmdlcy5yZW1vdmVkTm9kZUtleXMubWFwKGtleSA9PiBrZXlJZHhNYXAuZ2V0KGtleSkpLnNvcnQoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gcmVtb3ZhbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgIGRyYWZ0LnNwbGljZShyZW1vdmFsc1tpXSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3Tm9kZURhdGFBcnJheTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN5bmMgYSBsaW5rIGRhdGEgYXJyYXkgd2l0aCBhIHNldCBvZiBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgVGhlIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBHb0pTIG1vZGVsXHJcbiAgICogQHBhcmFtIGxpbmtEYXRhIFRoZSBsaW5rIGRhdGEgYXJyYXkgdG8gbWVyZ2UgdGhlc2UgY2hhbmdlcyB3aXRoXHJcbiAgICogQHBhcmFtIG1vZGVsIFJlcXVpcmVkIGlmIHlvdSBoYXZlIGRlZmluZWQgeW91ciBtb2RlbC5saW5rS2V5UHJvcGVydHkgdG8gYmUgc29tZXRoaW5nIG90aGVyIHRoYW4gJ2tleSdcclxuICAgKiBAcmV0dXJucyBBIGxpbmsgZGF0YSBhcnJheSwgbWVyZ2VkIHdpdGggdGhlIGNoYW5nZXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHN5bmNMaW5rRGF0YShjaGFuZ2VzOiBnby5JbmNyZW1lbnRhbERhdGEsIGxpbmtEYXRhOiBBcnJheTxnby5PYmplY3REYXRhPiwgbW9kZWw/OiBnby5HcmFwaExpbmtzTW9kZWwpIHtcclxuICAgIGlmICghY2hhbmdlcykgcmV0dXJuIGxpbmtEYXRhO1xyXG4gICAgaWYgKCFjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEgJiYgIWNoYW5nZXMuaW5zZXJ0ZWRMaW5rS2V5cyAmJiAhY2hhbmdlcy5yZW1vdmVkTGlua0tleXMpIHJldHVybiBsaW5rRGF0YTtcclxuXHJcbiAgICAvLyBtYWludGFpbiBhIG1hcCBvZiBtb2RpZmllZCBub2RlcyBmb3IgZmFzdCBsb29rdXAgZHVyaW5nIGluc2VydGlvblxyXG4gICAgY29uc3QgbW9kaWZpZWRMaW5rc01hcCA9IG5ldyBnby5NYXA8Z28uS2V5LCBnby5PYmplY3REYXRhPigpO1xyXG4gICAgLy8gZ2VuZXJhdGUgYSBtYXAgb2Yga2V5cyAtPiBpbmRpY2VzIGZvciBmYXN0ZXIgb3BlcmF0aW9uc1xyXG4gICAgY29uc3Qga2V5SWR4TWFwID0gbmV3IE1hcDxnby5LZXksIG51bWJlcj4oKTtcclxuICAgIGxpbmtEYXRhLmZvckVhY2goKGxkLCBpZHgpID0+IHtcclxuICAgICAgY29uc3Qga2V5ID0gbW9kZWwgPyBtb2RlbC5nZXRLZXlGb3JMaW5rRGF0YShsZCkgOiBsZFsna2V5J107XHJcbiAgICAgIGtleUlkeE1hcC5zZXQoa2V5LCBpZHgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gbGlua0RhdGEgaXMgaW1tdXRhYmxlLCBtb2RpZnkgaXQgdXNpbmcgdGhlIGltbWVyIHBhY2thZ2UncyBcInByb2R1Y2VcIiBmdW5jdGlvbiAoY3JlYXRlcyBuZXcgYXJyYXkpXHJcbiAgICBsaW5rRGF0YSA9IHByb2R1Y2UobGlua0RhdGEsIGRyYWZ0ID0+IHtcclxuICAgICAgLy8gYWNjb3VudCBmb3IgbW9kaWZpZWQgbGluayBkYXRhXHJcbiAgICAgIGlmIChjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEpIHtcclxuICAgICAgICBjaGFuZ2VzLm1vZGlmaWVkTGlua0RhdGEuZm9yRWFjaCgobGQ6IGdvLk9iamVjdERhdGEpID0+IHtcclxuICAgICAgICAgIC8vIEdldCB0aGUgdmFsdWUgb2YgdGhlIGxpbmsga2V5XHJcbiAgICAgICAgICBjb25zdCBrZXkgPSBtb2RlbCA/IG1vZGVsLmdldEtleUZvckxpbmtEYXRhKGxkKSA6IGxkWydrZXknXTtcclxuICAgICAgICAgIG1vZGlmaWVkTGlua3NNYXAuc2V0KGtleSwgbGQpO1xyXG4gICAgICAgICAgY29uc3QgaWR4ID0ga2V5SWR4TWFwLmdldChrZXkpO1xyXG4gICAgICAgICAgaWYgKGlkeCAhPT0gdW5kZWZpbmVkICYmIGlkeCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGRyYWZ0W2lkeF0gPSBsZDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gYWNjb3VudCBmb3IgaW5zZXJ0ZWQgbGluayBkYXRhXHJcbiAgICAgIGlmIChjaGFuZ2VzLmluc2VydGVkTGlua0tleXMpIHtcclxuICAgICAgICBjaGFuZ2VzLmluc2VydGVkTGlua0tleXMuZm9yRWFjaCgoa2V5OiBnby5LZXkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG5kID0gbW9kaWZpZWRMaW5rc01hcC5nZXQoa2V5KTtcclxuICAgICAgICAgIGlmIChuZCAmJiAha2V5SWR4TWFwLmhhcyhrZXkpKSB7XHJcbiAgICAgICAgICAgIGRyYWZ0LnB1c2gobmQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBhY2NvdW50IGZvciByZW1vdmVkIGxpbmsgZGF0YVxyXG4gICAgICBpZiAoY2hhbmdlcy5yZW1vdmVkTGlua0tleXMpIHtcclxuICAgICAgICBjb25zdCByZW1vdmFscyA9IGNoYW5nZXMucmVtb3ZlZExpbmtLZXlzLm1hcChrZXkgPT4ga2V5SWR4TWFwLmdldChrZXkpKS5zb3J0KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IHJlbW92YWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICBkcmFmdC5zcGxpY2UocmVtb3ZhbHNbaV0sIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGxpbmtEYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3luYyBtb2RlbERhdGEgd2l0aCBhIHNldCBvZiBjaGFuZ2VzXHJcbiAgICogQHBhcmFtIGNoYW5nZXMgVGhlIHNldCBvZiBjaGFuZ2VzIHRvIHRoZSBHb0pTIG1vZGVsXHJcbiAgICogQHBhcmFtIG1vZGVsRGF0YSBUaGUgbW9kZWxEYXRhIHRvIG1lcmdlIHRoZXNlIGNoYW5nZXMgd2l0aFxyXG4gICAqIEByZXR1cm5zIEEgbW9kZWxEYXRhIG9iamVjdCwgbWVyZ2VkIHdpdGggdGhlIGNoYW5nZXNcclxuICAgKi9cclxuICBwdWJsaWMgc3RhdGljIHN5bmNNb2RlbERhdGEoY2hhbmdlczogZ28uSW5jcmVtZW50YWxEYXRhLCBtb2RlbERhdGE6IGdvLk9iamVjdERhdGEpIHtcclxuICAgIGlmICghY2hhbmdlcykgcmV0dXJuIG1vZGVsRGF0YTtcclxuICAgIGlmICghY2hhbmdlcy5tb2RlbERhdGEpIHJldHVybiBtb2RlbERhdGE7XHJcbiAgICBpZiAoY2hhbmdlcy5tb2RlbERhdGEpIHtcclxuICAgICAgcmV0dXJuIGNoYW5nZXMubW9kZWxEYXRhO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG59XHJcbiJdfQ==